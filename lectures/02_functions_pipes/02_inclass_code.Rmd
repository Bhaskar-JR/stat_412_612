---
title: "Piping and Functions"
author: "David Gerard"
date: "January 23, 2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Calculating a Geometric Mean

Create some random data
```{r}
x <- abs(rnorm(100))
head(x)
```

Create a new object after each function
```{r}
log_x <- log(x)
mean_logx <- mean(log_x)
exp(mean_logx)
```

Nest functions
```{r}
exp(mean(log(x)))
```

Overight original object
```{r, eval = FALSE}
x <- log(x)
x <- mean(x)
exp(x)
```

Use the pipe %>%
```{r}
library(tidyverse)
x %>%
  log() %>%
  mean() %>%
  exp()
```

Piping always inserts the output into the first 
argument of the next function
```{r}
x[1] <- NA
x %>%
  log() %>%
  mean(na.rm = TRUE) %>%
  exp()
```


### exercise solutions
```{r}
rnorm(n = 100, sd = 10) %>%
  sort(decreasing = FALSE) %>%
  diff() %>%
  mean() %>%
  round(digits = 1)
```

```{r}
rnorm(100) %>%
  sort()

sort(rnorm(100))
```

# Functions and Function Creation

A very basic function
```{r}
add_two <- function(a, b) {
  ## tons of code goes here
  c <- a + b
  return(c)
}
add_two(a = 2, b = 5)
```

The book example
```{r}
df <- data.frame(
  a = rnorm(100),
  b = rnorm(100),
  c = rnorm(100),
  d = rnorm(100)
)
head(df)
```

Suppose the goal is to transform these variables so that all elements are between 0 and 1


Copy code
  
- Obnoxious
- Subject to error
- If you have to change later, it is obnoxious and subject to error
```{r}
df$a <- ((df$a - min(df$a))) / (max(df$a) - min(df$a))
df$b <- ((df$b - min(df$b))) / (max(df$a) - min(df$b))
df$c <- ((df$c - min(df$c))) / (max(df$c) - min(df$c))
df$d <- ((df$d - min(df$d))) / (max(df$d) - min(df$d))
```

Create a function!

```{r}
x <- df$a

rescale1 <- function(x) {
  
  ## Calculate minimum -------------------
  min_x <- min(x, na.rm = TRUE)
  
  ## Rescale ----------------------------
  rescale_vec <- (x - min_x) / 
    (max(x, na.rm = TRUE) - min_x)
  
  return(rescale_vec)
}
rescale1(c(1, 2, 3))

df$a <- rescale1(df$a)
df$b <- rescale1(df$b)
df$c <- rescale1(df$c)
df$d <- rescale1(df$d)
```

```{r}
rescale1(c(NA, 1, 3, 4))
```


```{r}
x <- c(NA, NA, 2, 3, NA)
y <- c(NA, NA, 5, 6, 7)
both_na <- function(x, y) {
  na_x <- is.na(x)
  na_y <- is.na(y)
  index_vector <- 1:length(x)
  sum(na_x & na_y)  
}


sum(c(TRUE, TRUE, TRUE))
```

## If-then statements
```{r}
x <- 6
if (x > 5) {
  ## code
  "hurray!"
} else {
  ## other code
  "oh well"
}
```

The has-name function

Check if a vector has any names attached
if not then it will return FALSE for all elements

If yes, then it will return TRUE in the positions where the vector has a name
```{r}
x <- c(a = 1, 2, 3)
names(x)
has_name <- function(x) {
  nms <- names(x)
  if (is.null(nms)) {
    rep(FALSE, length(x))
  } else {
    !is.na(nms) & nms != ""
  }
}
x1 <- c(1,2,3)
x2 <- c(a = 1, 2,3)
has_name(x1)
```


Multiple conditional execution
```{r}
x <- -5
if (x > 5) {
  "Hurray!"
} else if (x > 0) {
  "oh well"
} else if (x > -10) {
  "oh boy"  
} else {
  "oh no"
}
```







